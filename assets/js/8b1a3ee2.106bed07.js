"use strict";(self.webpackChunkef_website_template=self.webpackChunkef_website_template||[]).push([[239],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function f(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),s=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,c=f(e,["components","mdxType","originalType","parentName"]),u=s(n),p=a,b=u["".concat(o,".").concat(p)]||u[p]||d[p]||l;return n?r.createElement(b,i(i({ref:t},c),{},{components:n})):r.createElement(b,i({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,i=new Array(l);i[0]=u;var f={};for(var o in t)hasOwnProperty.call(t,o)&&(f[o]=t[o]);f.originalType=e,f.mdxType="string"==typeof e?e:a,i[1]=f;for(var s=2;s<l;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6079:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>f,toc:()=>s});var r=n(7462),a=(n(7294),n(3905));const l={},i=void 0,f={permalink:"/EF-Informatik/02.12.2022-arbeiten-an-numtrip",editUrl:"https://github.com/GabrielMariethoz/EF-Informatik/tree/main/blog/02.12.2022-arbeiten-an-numtrip.md",source:"@site/blog/02.12.2022-arbeiten-an-numtrip.md",title:"02.12.2022-arbeiten-an-numtrip",description:"Zuerst habe ich die Funktion eingabe() so angepasst, dass sie eine Liste zur\xfcckgibt, welche die Position des vom Benutzer eingegebenen Elements der Matrix beinhaltet. In der Funktion habe ich ebenfalls eine neue Variable hinzugef\xfcgt, welche den Wert, der Position, welche der Benutzer eingegeben hat, hat.",date:"2023-03-16T17:35:54.000Z",formattedDate:"16. M\xe4rz 2023",tags:[],readingTime:.86,hasTruncateMarker:!1,authors:[],frontMatter:{},prevItem:{title:"02.09.2022 report",permalink:"/EF-Informatik/02.09.2022"},nextItem:{title:"26.08.2022 report",permalink:"/EF-Informatik/26.08.2022"}},o={authorsImageUrls:[]},s=[],c={toc:s};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Zuerst habe ich die Funktion eingabe() so angepasst, dass sie eine Liste zur\xfcckgibt, welche die Position des vom Benutzer eingegebenen Elements der Matrix beinhaltet. In der Funktion habe ich ebenfalls eine neue Variable hinzugef\xfcgt, welche den Wert, der Position, welche der Benutzer eingegeben hat, hat."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"self.alter_wert = self.matrix[int(self.feld_eingabe[0]) - 1][int(self.feld_eingabe[1]) - 1]\nreturn [int(self.feld_eingabe[0]) - 1, int(self.feld_eingabe[1]) - 1]\n")),(0,a.kt)("p",null,"Danach habe ich eine neue Funktion nachbarsfelder() eingebaut, die pr\xfcft, ob die Nachbarsfelder denselben Wert haben. Da habe ich die Rekursion gebraucht, um die Nachbarsfelder der Nachbarsfelder zu pr\xfcfen. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"def nachbarsfelder(self, feld: list):\n\n    if feld[0] > 0:\n        if self.matrix[feld[0] - 1][feld[1]] == self.alter_wert:\n            self.matrix[feld[0] - 1][feld[1]] = 0\n            self.nachbarsfelder([feld[0] - 1, feld[1]])\n    if feld[0] < 4:\n        if self.matrix[feld[0] + 1][feld[1]] == self.alter_wert:\n            self.matrix[feld[0] + 1][feld[1]] = 0\n            self.nachbarsfelder([feld[0] + 1, feld[1]])\n    if feld[1] > 0:\n        if self.matrix[feld[0]][feld[1] - 1] == self.alter_wert:\n            self.matrix[feld[0]][feld[1] - 1] = 0\n            self.nachbarsfelder([feld[0], feld[1] - 1])\n    if feld[1] < 4:\n        if self.matrix[feld[0]][feld[1] + 1] == self.alter_wert:\n            self.matrix[feld[0]][feld[1] + 1] = 0\n            self.nachbarsfelder([feld[0], feld[1] + 1])\n")))}d.isMDXComponent=!0}}]);